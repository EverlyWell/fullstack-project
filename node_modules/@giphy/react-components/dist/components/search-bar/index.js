"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@emotion/core");
var js_brand_1 = require("@giphy/js-brand");
var react_1 = __importStar(require("react"));
var useDebounce_1 = __importDefault(require("react-use/lib/useDebounce"));
var context_1 = require("./context");
var search_bar_channel_1 = __importDefault(require("./search-bar-channel"));
var search_button_1 = __importDefault(require("./search-button"));
var theme_1 = __importStar(require("./theme"));
function usePrevious(value) {
    var ref = react_1.useRef(value);
    react_1.useEffect(function () {
        ref.current = value;
    });
    return ref.current;
}
var SEARCH_DEBOUNCE = 500;
var Container = theme_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: flex;\n    background: white;\n    ", "\n"], ["\n    display: flex;\n    background: white;\n    ", "\n"])), function (props) { return theme_1.getSize(props.theme); });
var Input = theme_1.default.input(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    background: ", ";\n    box-sizing: border-box;\n    border: 0;\n    appearance: none;\n    font-weight: normal;\n    outline: 0;\n    font-size: 15px;\n    padding: 0 10px;\n    border-radius: 0;\n    text-overflow: ellipsis;\n    color: ", ";\n    &::placeholder {\n        color: ", ";\n    }\n    min-width: 150px;\n    flex: 1;\n    ", "\n"], ["\n    background: ", ";\n    box-sizing: border-box;\n    border: 0;\n    appearance: none;\n    font-weight: normal;\n    outline: 0;\n    font-size: 15px;\n    padding: 0 10px;\n    border-radius: 0;\n    text-overflow: ellipsis;\n    color: ", ";\n    &::placeholder {\n        color: ", ";\n    }\n    min-width: 150px;\n    flex: 1;\n    ",
    "\n"])), function (props) { return (props.theme.mode === 'dark' ? js_brand_1.giphyCharcoal : js_brand_1.giphyWhite); }, function (props) { return (props.theme.mode === 'dark' ? js_brand_1.giphyWhite : js_brand_1.giphyBlack); }, function (props) { return (props.theme.mode === 'dark' ? js_brand_1.giphyLightGrey : js_brand_1.giphyLightGrey); }, function (props) {
    return props.isUsernameSearch && core_1.css(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n            color: ", ";\n        "], ["\n            color: ", ";\n        "])), js_brand_1.giphyIndigo);
});
var SearchBar = function (_a) {
    var className = _a.className, _b = _a.placeholder, placeholder = _b === void 0 ? 'Search GIPHY' : _b, _c = _a.clear, clear = _c === void 0 ? false : _c;
    var _d = react_1.useContext(context_1.SearchContext), setSearch = _d.setSearch, activeChannel = _d.activeChannel, setActiveChannel = _d.setActiveChannel, term = _d.term, channelSearch = _d.channelSearch;
    // debounce local input
    var _e = react_1.useState(term), debouncedTerm = _e[0], setDebouncedInput = _e[1];
    // used to see if the last term was a '' before clearing
    var lastTerm = usePrevious(debouncedTerm);
    // set the term when it changes
    useDebounce_1.default(function () { return setSearch(debouncedTerm); }, SEARCH_DEBOUNCE, [debouncedTerm]);
    // used only to focus the input
    var inputRef = react_1.useRef(null);
    // we'll use this to see when we went from no channel to channel
    var previousActiveChannel = usePrevious(activeChannel);
    react_1.useEffect(function () {
        var _a;
        // if we know have a channel, focus and clear the input
        // so the user can search the channel
        if (activeChannel && !previousActiveChannel) {
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            setDebouncedInput('');
        }
    }, [debouncedTerm, activeChannel]);
    // a pill could have been clicked, update our local term state
    react_1.useEffect(function () {
        setDebouncedInput(term);
    }, [term]);
    var _f = react_1.useState(clear), isCleared = _f[0], setCleared = _f[1];
    react_1.useEffect(function () {
        setCleared(clear);
    }, [clear]);
    // key ups to clear the active channel
    var onKeyUp = function (e) {
        switch (e.keyCode) {
            case 8: // backspace
                if (lastTerm === '') {
                    setActiveChannel(undefined);
                }
                break;
            case 27: // esc
                setActiveChannel(undefined);
                break;
            default:
                break;
        }
    };
    return (react_1.default.createElement(Container, { className: [SearchBar.className, className].join(' ') },
        react_1.default.createElement(search_bar_channel_1.default, null),
        react_1.default.createElement(Input, { isUsernameSearch: !!channelSearch, onChange: function (_a) {
                var value = _a.target.value;
                if (!isCleared || value !== '') {
                    setCleared(false);
                    setDebouncedInput(value);
                }
            }, value: isCleared ? '' : debouncedTerm, placeholder: activeChannel ? "Search " + activeChannel.display_name : placeholder, autoCapitalize: "off", autoCorrect: "off", autoComplete: "off", ref: inputRef, onKeyUp: onKeyUp }),
        react_1.default.createElement(search_button_1.default, null)));
};
SearchBar.className = 'giphy-search-bar';
exports.default = SearchBar;
var templateObject_1, templateObject_2, templateObject_3;
//# sourceMappingURL=index.js.map